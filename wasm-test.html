<!doctype html>
<html lang="en">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>WASM circle collision demo</title>
<link rel="stylesheet" href="styles.css">
<style>
    /* Demo-specific color variables */
    :root {
        /* Enhanced circle styling */
        --circle-alpha: 0.85;
        --circle-stroke-alpha: 0.9;

        /* Modern color palette - vibrant yet sophisticated */
        --circle-a-normal: rgb(64 224 208 / var(--circle-alpha)); /* turquoise */
        --circle-a-hit: rgb(255 107 107 / var(--circle-alpha)); /* coral red */
        --circle-b-normal: rgb(138 43 226 / var(--circle-alpha)); /* blue violet */
        --circle-b-hit: rgb(255 165 0 / var(--circle-alpha)); /* orange */

        /* Circle stroke colors */
        --circle-a-stroke: rgb(64 224 208 / var(--circle-stroke-alpha));
        --circle-a-stroke-hit: rgb(255 107 107 / var(--circle-stroke-alpha));
        --circle-b-stroke: rgb(138 43 226 / var(--circle-stroke-alpha));
        --circle-b-stroke-hit: rgb(255 165 0 / var(--circle-stroke-alpha));

        /* Enhanced connecting line */
        --line-color: rgba(255, 255, 255, 0.7);
        --line-glow: rgba(64, 224, 208, 0.4);
        --line-style: 4, 8; /* dash pattern: 4px dash, 8px gap */
    }
</style>

<div id="wrap" class="grid-layout two-column">
    <canvas id="canvas" class="modern-canvas"></canvas>
    <div id="side" class="glass-panel">
        <h3 class="gradient-title">WASM circle collision</h3>
        <div class="stat-row">Intersect: <span id="inter" class="pill">false</span></div>
        <div class="stat-row">Distance: <span id="dist" class="pill">0</span></div>
        <div class="stat-row">Penetration: <span id="pen" class="pill">0</span></div>
        <p class="description-text">Drag the circles. Colors switch on intersection.<br/>
            Call boundary: <code class="code-highlight">circle_collision(x1,y1,r1,x2,y2,r2)</code> (1 call/frame).</p>
    </div>
</div>

<script type="module">
    import init, {run, circle_collision} from "./pkg/silly_demos.js";

    await init();
    await run();

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const interEl = document.getElementById("inter");
    const distEl = document.getElementById("dist");
    const penEl = document.getElementById("pen");

    function setupCanvas() {
        // Get the display size (CSS pixels)
        const rect = canvas.getBoundingClientRect();
        const displayWidth = rect.width;
        const displayHeight = rect.height;
        
        // Ensure minimum valid dimensions
        if (displayWidth <= 0 || displayHeight <= 0) return;
        
        // Get device pixel ratio for crisp rendering
        const dpr = window.devicePixelRatio || 1;
        
        // Set the internal buffer size
        canvas.width = displayWidth * dpr;
        canvas.height = displayHeight * dpr;
        
        // Scale the context and center the coordinate system
        ctx.setTransform(dpr, 0, 0, dpr, canvas.width / 2, canvas.height / 2);
        
        // Store current dimensions for use in draw function
        canvas._displayWidth = displayWidth;
        canvas._displayHeight = displayHeight;
    }

    // Store initial circle positions relative to center
    let initialA = {x: -140, y: 0, r: 90};
    let initialB = {x: 140, y: 0, r: 110};

    // Setup canvas initially
    setupCanvas();
    
    // Handle window resize with immediate response
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        // Force immediate canvas setup
        setupCanvas();
        // Add a small delay to handle any layout settling
        resizeTimeout = setTimeout(setupCanvas, 10);
    });

    // Initialize circles with centered positions
    const A = {x: initialA.x, y: initialA.y, r: initialA.r, offx: 0, offy: 0};
    const B = {x: initialB.x, y: initialB.y, r: initialB.r, offx: 0, offy: 0};

    const pt = (e) => {
        const rect = canvas.getBoundingClientRect();
        // Convert screen coordinates to centered canvas coordinates
        return {
            x: (e.clientX - rect.left) - rect.width / 2, 
            y: (e.clientY - rect.top) - rect.height / 2
        };
    };
    const hit = (c, p) => {
        const dx = p.x - c.x, dy = p.y - c.y;
        return dx * dx + dy * dy <= c.r * c.r;
    };

    let dragging = null;
    canvas.addEventListener("pointerdown", (e) => {
        const p = pt(e);
        if (hit(A, p)) {
            dragging = A;
            A.offx = p.x - A.x;
            A.offy = p.y - A.y;
        } else if (hit(B, p)) {
            dragging = B;
            B.offx = p.x - B.x;
            B.offy = p.y - B.y;
        }
        canvas.setPointerCapture(e.pointerId);
    });
    canvas.addEventListener("pointermove", (e) => {
        if (!dragging) return;
        const p = pt(e);
        dragging.x = p.x - dragging.offx;
        dragging.y = p.y - dragging.offy;
    });
    const stopDrag = () => dragging = null;
    canvas.addEventListener("pointerup", stopDrag);
    canvas.addEventListener("pointercancel", stopDrag);
    canvas.addEventListener("pointerleave", stopDrag);

    const cssVar = (n) => getComputedStyle(document.documentElement).getPropertyValue(n).trim();

    function drawCircle(c, fillVar, strokeVar) {
        // Create radial gradient for depth
        const gradient = ctx.createRadialGradient(
            c.x - c.r * 0.3, c.y - c.r * 0.3, 0,
            c.x, c.y, c.r
        );
        const fillColor = cssVar(fillVar);
        gradient.addColorStop(0, fillColor.replace(/\/[^)]*\)/, '/ 0.95)'));
        gradient.addColorStop(1, fillColor);
        
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Enhanced stroke with glow effect
        ctx.shadowColor = cssVar(strokeVar);
        ctx.shadowBlur = 8;
        ctx.lineWidth = 3;
        ctx.strokeStyle = cssVar(strokeVar);
        ctx.stroke();
        
        // Reset shadow
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
    }

    function draw() {
        const res = circle_collision(A.x, A.y, A.r, B.x, B.y, B.r);
        interEl.textContent = res.intersect ? "yes" : "no";
        distEl.textContent = res.distance.toFixed(2);
        penEl.textContent = res.penetration.toFixed(2);

        // Clear the entire canvas using stored dimensions
        const width = canvas._displayWidth || canvas.getBoundingClientRect().width;
        const height = canvas._displayHeight || canvas.getBoundingClientRect().height;
        ctx.clearRect(-width / 2, -height / 2, width, height);
        
        // Draw connecting line with glow
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        
        // Glow effect for line
        ctx.shadowColor = cssVar("--line-glow");
        ctx.shadowBlur = 6;
        ctx.lineWidth = 2;
        ctx.strokeStyle = cssVar("--line-color");
        ctx.setLineDash(cssVar("--line-style").split(",").map(parseFloat));
        ctx.stroke();
        
        // Reset shadow and dash
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.setLineDash([]);

        // Draw circles with appropriate colors and strokes
        if (res.intersect) {
            drawCircle(A, "--circle-a-hit", "--circle-a-stroke-hit");
            drawCircle(B, "--circle-b-hit", "--circle-b-stroke-hit");
        } else {
            drawCircle(A, "--circle-a-normal", "--circle-a-stroke");
            drawCircle(B, "--circle-b-normal", "--circle-b-stroke");
        }

        requestAnimationFrame(draw);
    }

    draw();
</script>

</html>
