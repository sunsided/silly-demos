<!doctype html>
<html lang="en">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>WASM circle collision demo</title>
<style>
    html, body {
        height: 100%;
        margin: 0;
        background: #111;
        color: #ddd;
        font: 14px/1.3 system-ui, sans-serif;
    }

    #wrap {
        display: grid;
        grid-template-columns: 1fr 320px;
        gap: 16px;
        height: 100%;
    }

    #side {
        padding: 12px;
    }

    #canvas {
        background: #181818;
        display: block;
        width: 100%;
        height: 100%;
    }

    .stat {
        margin: 6px 0;
    }

    .pill {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 12px;
        background: #333;
    }
</style>

<div id="wrap">
    <canvas id="canvas" width="900" height="600"></canvas>
    <div id="side">
        <h3>WASM circle collision</h3>
        <div class="stat">Intersect: <span id="inter" class="pill">false</span></div>
        <div class="stat">Distance: <span id="dist" class="pill">0</span></div>
        <div class="stat">Penetration: <span id="pen" class="pill">0</span></div>
        <p>Drag the circles. Colors switch on intersection.<br/>
            Call boundary: <code>circle_collision(x1,y1,r1,x2,y2,r2)</code> (1 call/frame).</p>
    </div>
</div>

<script type="module">
    (async () => {
        console.log("Loading …");

        // 1) Load wasm-bindgen JS glue dynamically (wasm-pack style)
        const mod = await import("./pkg/silly_demos.js");

        // 2) Initialize WASM; prefer URL, fall back to bytes to bypass MIME quirks
        const wasmUrl = new URL("./pkg/silly_demos_bg.wasm", import.meta.url);
        try {
            await mod.default(wasmUrl);               // fast path (instantiateStreaming)
        } catch (e) {
            console.warn("URL init failed, retrying with bytes:", e);
            const resp = await fetch(wasmUrl);
            const bytes = await resp.arrayBuffer();
            await mod.default(bytes);                 // non-streaming init
        }

        const {circle_collision} = mod;

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const interEl = document.getElementById("inter");
        const distEl = document.getElementById("dist");
        const penEl = document.getElementById("pen");

        // --- DPR-correct canvas setup ---
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const cw = canvas.clientWidth;
            const ch = canvas.clientHeight;

            // Match backing store to CSS size * DPR
            const bsW = Math.max(1, Math.round(cw * dpr));
            const bsH = Math.max(1, Math.round(ch * dpr));
            if (canvas.width !== bsW || canvas.height !== bsH) {
                canvas.width = bsW;
                canvas.height = bsH;
            }

            // Draw in CSS pixel space
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        setupCanvas();
        window.addEventListener("resize", setupCanvas);
        // Optional: react to DPR changes on zoom/undock
        try {
            const mq = matchMedia(`(resolution: ${window.devicePixelRatio || 1}dppx)`);
            mq.addEventListener("change", setupCanvas);
        } catch { /* older browsers */
        }

        // Scene state (coords in CSS pixels)
        const A = {x: 280, y: 300, r: 90, dragging: false, offx: 0, offy: 0};
        const B = {x: 560, y: 300, r: 110, dragging: false, offx: 0, offy: 0};

        // Pointer utils (CSS pixel space, no scaling)
        const pt = (e) => {
            const rect = canvas.getBoundingClientRect();
            return {x: e.clientX - rect.left, y: e.clientY - rect.top};
        };
        const hit = (c, p) => {
            const dx = p.x - c.x, dy = p.y - c.y;
            return dx * dx + dy * dy <= c.r * c.r;
        };

        let dragging = null;

        canvas.addEventListener("pointerdown", (e) => {
            const p = pt(e);
            if (hit(A, p)) {
                dragging = A;
                A.dragging = true;
                A.offx = p.x - A.x;
                A.offy = p.y - A.y;
            } else if (hit(B, p)) {
                dragging = B;
                B.dragging = true;
                B.offx = p.x - B.x;
                B.offy = p.y - B.y;
            }
            canvas.setPointerCapture(e.pointerId);
        });

        canvas.addEventListener("pointermove", (e) => {
            if (!dragging) return;
            const p = pt(e);
            dragging.x = p.x - dragging.offx;
            dragging.y = p.y - dragging.offy;
        });

        const stopDrag = () => {
            if (dragging) {
                dragging.dragging = false;
                dragging = null;
            }
        };
        canvas.addEventListener("pointerup", stopDrag);
        canvas.addEventListener("pointercancel", stopDrag);
        canvas.addEventListener("pointerleave", stopDrag);

        function drawCircle(c, fill, stroke = "#ddd", alpha = 0.6) {
            ctx.beginPath();
            ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
            // semi-transparent fill
            ctx.fillStyle = fill.replace("rgb", "rgba").replace(")", `,${alpha})`);
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = stroke;
            ctx.stroke();
        }

        function draw() {
            const res = circle_collision(A.x, A.y, A.r, B.x, B.y, B.r);

            interEl.textContent = res.intersect;
            distEl.textContent = res.distance.toFixed(2);
            penEl.textContent = res.penetration.toFixed(2);

            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

            const cA = res.intersect ? "rgb(198,40,40)" : "rgb(46,125,50)";
            const cB = res.intersect ? "rgb(239,83,80)" : "rgb(102,187,106)";
            drawCircle(A, cA);
            drawCircle(B, cB);

            ctx.beginPath();
            ctx.moveTo(A.x, A.y);
            ctx.lineTo(B.x, B.y);
            ctx.strokeStyle = "#444";
            ctx.stroke();

            requestAnimationFrame(draw);
        }

        console.log("Init complete. Drawing …");
        draw();
    })();
</script>

</html>
