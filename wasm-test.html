<!doctype html>
<html lang="en">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>WASM circle collision demo</title>
<link rel="stylesheet" href="styles.css">
<style>
    /* Demo-specific color variables */
    :root {
        /* Enhanced circle styling */
        --circle-alpha: 0.85;
        --circle-stroke-alpha: 0.9;

        /* Modern color palette - vibrant yet sophisticated */
        --circle-a-normal: rgb(64 224 208 / var(--circle-alpha)); /* turquoise */
        --circle-a-hit: rgb(255 107 107 / var(--circle-alpha)); /* coral red */
        --circle-b-normal: rgb(138 43 226 / var(--circle-alpha)); /* blue violet */
        --circle-b-hit: rgb(255 165 0 / var(--circle-alpha)); /* orange */

        /* Circle stroke colors */
        --circle-a-stroke: rgb(64 224 208 / var(--circle-stroke-alpha));
        --circle-a-stroke-hit: rgb(255 107 107 / var(--circle-stroke-alpha));
        --circle-b-stroke: rgb(138 43 226 / var(--circle-stroke-alpha));
        --circle-b-stroke-hit: rgb(255 165 0 / var(--circle-stroke-alpha));

        /* Enhanced connecting line */
        --line-color: rgba(255, 255, 255, 0.7);
        --line-glow: rgba(64, 224, 208, 0.4);
        --line-style: 4, 8; /* dash pattern: 4px dash, 8px gap */
    }
</style>

<div id="wrap" class="grid-layout two-column">
    <canvas id="canvas" class="modern-canvas" width="900" height="600"></canvas>
    <div id="side" class="glass-panel">
        <h3 class="gradient-title">WASM circle collision</h3>
        <div class="stat-row">Intersect: <span id="inter" class="pill">false</span></div>
        <div class="stat-row">Distance: <span id="dist" class="pill">0</span></div>
        <div class="stat-row">Penetration: <span id="pen" class="pill">0</span></div>
        <p class="description-text">Drag the circles. Colors switch on intersection.<br/>
            Call boundary: <code class="code-highlight">circle_collision(x1,y1,r1,x2,y2,r2)</code> (1 call/frame).</p>
    </div>
</div>

<script type="module">
    import init, {run, circle_collision} from "./pkg/silly_demos.js";

    await init();
    await run();

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const interEl = document.getElementById("inter");
    const distEl = document.getElementById("dist");
    const penEl = document.getElementById("pen");

    function setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const cw = canvas.clientWidth, ch = canvas.clientHeight;
        const bsW = Math.round(cw * dpr), bsH = Math.round(ch * dpr);
        if (canvas.width !== bsW || canvas.height !== bsH) {
            canvas.width = bsW;
            canvas.height = bsH;
        }
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    setupCanvas();
    window.addEventListener("resize", setupCanvas);

    const A = {x: 280, y: 300, r: 90, offx: 0, offy: 0};
    const B = {x: 560, y: 300, r: 110, offx: 0, offy: 0};

    const pt = (e) => {
        const r = canvas.getBoundingClientRect();
        return {x: e.clientX - r.left, y: e.clientY - r.top};
    };
    const hit = (c, p) => {
        const dx = p.x - c.x, dy = p.y - c.y;
        return dx * dx + dy * dy <= c.r * c.r;
    };

    let dragging = null;
    canvas.addEventListener("pointerdown", (e) => {
        const p = pt(e);
        if (hit(A, p)) {
            dragging = A;
            A.offx = p.x - A.x;
            A.offy = p.y - A.y;
        } else if (hit(B, p)) {
            dragging = B;
            B.offx = p.x - B.x;
            B.offy = p.y - B.y;
        }
        canvas.setPointerCapture(e.pointerId);
    });
    canvas.addEventListener("pointermove", (e) => {
        if (!dragging) return;
        const p = pt(e);
        dragging.x = p.x - dragging.offx;
        dragging.y = p.y - dragging.offy;
    });
    const stopDrag = () => dragging = null;
    canvas.addEventListener("pointerup", stopDrag);
    canvas.addEventListener("pointercancel", stopDrag);
    canvas.addEventListener("pointerleave", stopDrag);

    const cssVar = (n) => getComputedStyle(document.documentElement).getPropertyValue(n).trim();

    function drawCircle(c, fillVar, strokeVar) {
        // Create radial gradient for depth
        const gradient = ctx.createRadialGradient(
            c.x - c.r * 0.3, c.y - c.r * 0.3, 0,
            c.x, c.y, c.r
        );
        const fillColor = cssVar(fillVar);
        gradient.addColorStop(0, fillColor.replace(/\/[^)]*\)/, '/ 0.95)'));
        gradient.addColorStop(1, fillColor);
        
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Enhanced stroke with glow effect
        ctx.shadowColor = cssVar(strokeVar);
        ctx.shadowBlur = 8;
        ctx.lineWidth = 3;
        ctx.strokeStyle = cssVar(strokeVar);
        ctx.stroke();
        
        // Reset shadow
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
    }

    function draw() {
        const res = circle_collision(A.x, A.y, A.r, B.x, B.y, B.r);
        interEl.textContent = res.intersect ? "yes" : "no";
        distEl.textContent = res.distance.toFixed(2);
        penEl.textContent = res.penetration.toFixed(2);

        ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        
        // Draw connecting line with glow
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        
        // Glow effect for line
        ctx.shadowColor = cssVar("--line-glow");
        ctx.shadowBlur = 6;
        ctx.lineWidth = 2;
        ctx.strokeStyle = cssVar("--line-color");
        ctx.setLineDash(cssVar("--line-style").split(",").map(parseFloat));
        ctx.stroke();
        
        // Reset shadow and dash
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.setLineDash([]);

        // Draw circles with appropriate colors and strokes
        if (res.intersect) {
            drawCircle(A, "--circle-a-hit", "--circle-a-stroke-hit");
            drawCircle(B, "--circle-b-hit", "--circle-b-stroke-hit");
        } else {
            drawCircle(A, "--circle-a-normal", "--circle-a-stroke");
            drawCircle(B, "--circle-b-normal", "--circle-b-stroke");
        }

        requestAnimationFrame(draw);
    }

    draw();
</script>

</html>
